/*
 * SystemController
 *
 * Copyright (C) 2022, HENSOLDT Cyber GmbH
 */

#include <string.h>

#include <camkes/io.h>
#include <camkes.h>

// includes for headers in /util_libs/libplatsupport/arch_include/arm/platsupport/
#include <platsupport/clock.h>
#include <platsupport/reset.h>

#include "plat/clock_bindings.h"
#include "plat/reset_bindings.h"
#include "plat/plat.h"
#include "systemController_rpc.h"

#include "systemController_plat.h"

#include "OS_Error.h"
#include "lib_debug/Debug.h"

/* SystemController provides access to hardware
 *  - Clock controller
 *  - Reset controller
 *
 * It provides a respective high-level interface to clients, which want to
 *  - enable a device
 *  - disable a device
 *  - ...
 * and therefore have to follow predefined steps for both clock and reset
 * controller configuration. These steps vary from platform to platform
 * and have to be identified within a corresponding Technical Reference Manual (TRM).
*/

static sys_ctrl_ctx_t m_sys_ctrl_ctx;

#ifdef BPMP_EXISTS
/******************************************************************************
* BPMP connection prototypes (currently hard-coded)
******************************************************************************/

extern void *sysctrl_bpmp_buf;
size_t sysctrl_bpmp_get_size(void);

typedef struct bpmpserver_interface_data {
    void *bpmpserver_shared_mem;
    int (*bpmpserver_call)(int mrq, size_t tx_size, size_t *bytes_rxd);
    size_t shared_mem_size;
} bpmpserver_interface_data_t;

static bpmpserver_interface_data_t bpmpserver_private_data;
#endif

/* Prototypes for these functions are not generated by the camkes templates yet */
seL4_Word sysctrl_uart_get_sender_id(void);


/******************************************************************************
* Generic functions to set up and control administrative features
******************************************************************************/

static inline bool check_clk_initialised(sys_ctrl_ctx_t *ctx, clk_id_t clk_id) {
    return ctx->clock_table[clk_id].initialised;
}

static inline bool check_valid_clk_id(clk_id_t clk_id) {
    return (clk_id >= 0 && clk_id < NCLOCKS);
}

static inline bool check_valid_clock_gate(clock_gate_t clock_gate) {
    return (clock_gate >= 0 && clock_gate <= NCLKGATES);
}

static inline bool check_is_owner(sys_ctrl_ctx_t *ctx, clk_id_t clk_id, seL4_Word client_id) {
    return (ctx->clock_table[clk_id].owner == client_id);
}


/******************************************************************************
* Interface specific functions
******************************************************************************/

// functions for if_OS_SystemController_UART
seL4_Word get_client_id(enum sysctrl_interfaces sysctrl_if) {
    if(sysctrl_if == IF_UART)
        return sysctrl_uart_get_sender_id();
    else
        return -1;
}


/******************************************************************************
* Wrapper around platform specific functions
******************************************************************************/

// Initialise a new clock
int init_clock(sys_ctrl_ctx_t *ctx, clk_id_t clk_id) {
    int error = 0;

    if(!check_valid_clk_id(clk_id)) {
        ZF_LOGE("Invalid clock ID");
        error = -EINVAL;
        goto out;
    }

    seL4_Word client_id = get_client_id(IF_UART);

    if(check_clk_initialised(ctx, clk_id)) {
        if(!check_is_owner(ctx, clk_id, client_id)) {
            ZF_LOGE("Clock is already initialised by another owner");
            error = -EBUSY;
            goto out;
        }
        else {
            error = 0;
            goto out;
        }
    }

    /* Call to clk_get_clock() in /util/libplatsupport/arch_include/arm/platsupport/clock.h, which
     * redirects to the actual plat support get_clock() implementation
     */
    clock_entry_t *clk_entry = &(ctx->clock_table[clk_id]);
    clk_entry->clk = clk_get_clock(&(ctx->io_ops.clock_sys), clk_id);

    if(!clk_entry->clk) {
        ZF_LOGE("Failed to get clock for clock ID %d", clk_id);
        error = -ENODEV;
        goto out;
    }

    clk_entry->initialised = true;
    clk_entry->owner = client_id;

out:
    return error;
}

/* Within /util/libplatsupport/arch_include/arm/platsupport/clock.h, the following clock gate typedefs are defined
 *  - enum clock_gate
 *  - enum clock_gate_mode
 * These enums are filled by the respective platform specific clock header, as provided within
 * /util/libplatsupport/plat_include/<platform>/platsupport/plat/clock.h
 */

// Set clock gate
int set_gate_mode(sys_ctrl_ctx_t *ctx, clock_gate_t gate, clock_gate_mode_t mode) {
    /* TODO: Some basic form of access control to the gates?,
     * Don't want a component to turn off the underneath another component
     */

    /* Call to clk_gate_enable() in /util/libplatsupport/arch_include/arm/platsupport/clock.h, which
     * redirects to the actual plat support gate_enable() implementation
     */
    int error = clk_gate_enable(&(ctx->io_ops.clock_sys), gate, mode);

    return error;
}

// Get clock source
uint32_t get_clock_source(sys_ctrl_ctx_t *ctx, clk_id_t clk_id) {
    uint32_t clock_source = 0;

    ZF_LOGE("Called get_clock_source() with clk_id = %d", clk_id);

    if(!check_valid_clk_id(clk_id)) {
        ZF_LOGE("Invalid clock ID");
        clock_source = 0;
        goto out;
    }

    seL4_Word client_id = get_client_id(IF_UART);

    if(!check_clk_initialised(ctx, clk_id)) {
        ZF_LOGE("Clock isn't initialised");
        clock_source = 0;
        goto out;
    }

    if(!check_is_owner(ctx, clk_id, client_id)) {
        ZF_LOGE("Client is not the owner of this clock");
        clock_source = 0;
        goto out;
    }

    /* Call to clk_get_source() in /util/libplatsupport/arch_include/arm/platsupport/clock.h, which
     * redirects to the actual plat support get_source() implementation
     */
    clock_source = clk_get_source(ctx->clock_table[clk_id].clk);

out:
    return clock_source;

}

// Set clock source
uint32_t set_clock_source(sys_ctrl_ctx_t *ctx, clk_id_t clk_id, uint32_t clk_src) {
    uint32_t clock_source = 0;

    ZF_LOGE("Called set_clock_source() with clk_id = %d", clk_id);

    if(!check_valid_clk_id(clk_id)) {
        ZF_LOGE("Invalid clock ID");
        clock_source = 0;
        goto out;
    }

    seL4_Word client_id = get_client_id(IF_UART);

    if(!check_clk_initialised(ctx, clk_id)) {
        ZF_LOGE("Clock isn't initialised");
        clock_source = 0;
        goto out;
    }

    if(!check_is_owner(ctx, clk_id, client_id)) {
        ZF_LOGE("Client is not the owner of this clock");
        clock_source = 0;
        goto out;
    }

    /* Call to clk_set_source() in /util/libplatsupport/arch_include/arm/platsupport/clock.h, which
     * redirects to the actual plat support set_source() implementation
     */
    clock_source = clk_set_source(ctx->clock_table[clk_id].clk, clk_src);

out:
    return clock_source;

}

// Get current frequency of a clock
freq_t get_freq(sys_ctrl_ctx_t *ctx, clk_id_t clk_id) {
    freq_t freq = 0;

    ZF_LOGE("Called get_freq() with clk_id = %d", clk_id);

    if(!check_valid_clk_id(clk_id)) {
        ZF_LOGE("Invalid clock ID");
        freq = 0;
        goto out;
    }

    seL4_Word client_id = get_client_id(IF_UART);

    if(!check_clk_initialised(ctx, clk_id)) {
        ZF_LOGE("Clock isn't initialised");
        freq = 0;
        goto out;
    }

    if(!check_is_owner(ctx, clk_id, client_id)) {
        ZF_LOGE("Client ist not the owner of this clock");
        freq = 0;
        goto out;
    }

    /* Call to clk_get_freq() in /util/libplatsupport/arch_include/arm/platsupport/clock.h, which
     * redirects to the actual plat support get_freq() implementation
     */
    freq = clk_get_freq(ctx->clock_table[clk_id].clk);

out:
    return freq;
}

// Set new frequency of a clock
freq_t set_freq(sys_ctrl_ctx_t *ctx, clk_id_t clk_id, freq_t hz) {
    freq_t set_freq = 0;

    ZF_LOGE("Called set_freq() with clk_id = %d", clk_id);

    if(!check_valid_clk_id(clk_id)) {
        ZF_LOGE("Invalid clock ID");
        set_freq = 0;
        goto out;
    }

    seL4_Word client_id = get_client_id(IF_UART);

    if(!check_clk_initialised(ctx, clk_id)) {
        ZF_LOGE("Clock isn't initialised");
        set_freq = 0;
        goto out;
    }

    if(!check_is_owner(ctx, clk_id, client_id)) {
        ZF_LOGE("Client is not the owner of this clock");
        set_freq = 0;
        goto out;
    }

    /* Call to clk_set_freq() in /util/libplatsupport/arch_include/arm/platsupport/clock.h, which
     * redirects to the actual plat support set_freq() implementation
     */
    set_freq = clk_set_freq(ctx->clock_table[clk_id].clk, hz);

out:
    return set_freq;
}

// Register a clock as child of another clock, which acts as the parent clock in the clock tree
int register_child_clock(sys_ctrl_ctx_t *ctx, clk_id_t parent, clk_id_t child) {
    int error = 0;

    if(!check_valid_clk_id(parent) || !check_valid_clk_id(child)) {
        error = -EINVAL;
        goto out;
    }

    seL4_Word client_id = get_client_id(IF_UART);

    if(!check_clk_initialised(ctx, parent)) {
        ZF_LOGE("Parent clock isn't initialised");
        error = -EPERM;
        goto out;
    }

    if(!check_is_owner(ctx, parent, client_id)) {
        ZF_LOGE("Client is not the owner of the parent clock");
        error = -EPERM;
        goto out;
    }

    if(!check_clk_initialised(ctx, child)) {
        ZF_LOGE("Child clock isn't initialised");
        error = -EPERM;
        goto out;
    }

    if(!check_is_owner(ctx, child, client_id)) {
        ZF_LOGE("Client is not the owner of the child clock");
        error = -EPERM;
        goto out;
    }

    // Call to clk_register_child() function in /util_libs/libplatsupport/src/arch/arm/clock.c
    clk_register_child(ctx->clock_table[parent].clk, ctx->clock_table[child].clk);
    error = 0;

out:
    return error;
}

int reset_assert(sys_ctrl_ctx_t *ctx, reset_id_t id) {
    // Call reset_sys_assert() function in /util_libs/libplatsupport/arch_include/arm/platsupport/reset.h,
    // which then forwards to plat specific reset_assert function
    return reset_sys_assert(&(ctx->io_ops.reset_sys), id);
}

int reset_deassert(sys_ctrl_ctx_t *ctx, reset_id_t id) {
    // Call reset_sys_deassert() function in /util_libs/libplatsupport/arch_include/arm/platsupport/reset.h,
    // which then forwards to plat specific reset_deassert function
    return reset_sys_deassert(&(ctx->io_ops.reset_sys), id);
}


/******************************************************************************
* if_OS_SystemController_UART specific functions
******************************************************************************/

/* Concept (currently for Nvidia Tegra platforms)
 * - a client component knows local device identifiers, e.g. for UART
 * having the UART_CONFIG_ID as part of /plat/<platform>/plat_uart.cmake within the
 * TRENTOS UART component
 * - this device identifier maps to a corresponding device id in /util_libs/libplatsupport,
 * e.g. id 5 for NV_UARTB_ASYNC
 * - the selected local device identifier is sent via the function "int enable(uart_id)" from
 * a client to the SystemController
 * - within the corresponding libplatsupport clock driver, the device id is mapped to a specific clock register
 * (e.g. CLK_RST_CONTROLLER_CLK_OUT_ENB_L/H/U/V/W/X/Y_0) by deriving
 *  - the actual address offset (e.g. CLK_RST_CONTROLLER_CLK_OUT_ENB_L_0)
 *  - the actual bit to set at respective address offset (e.g. for UARTB the CLK_ENB_UARTB)
 *  - the corresponding source register offset (e.g. CLK_RST_CONTROLLER_CLK_SOURCE_UARTB_0)
 * - within the corresponding libplatsupport reset driver, the device id is mapped to a specific reset register
 * (e.g. CLK_RST_CONTROLLER_RST_DEVICES_L/H/U/V/W/X/Y_0) by deriving
 *  - the actual address offset (e.g. CLK_RST_CONTROLLER_RST_DEVICES_L_0)
 *  - the actual bit to set at respective address offset (e.g. SWR_UARTB_RST)
 * - the respective driver has to convert the absolute bit value to a register relative bit value, and
 * therefore calculates
 *  - "clk_id mod 32", e.g. "CLK_ENB_UARTB mod 32"
 *  - "reset_id mod 32", e.g. "SWR_UARTB_RST mod 32"
 * - a concrete register address is then built by summing device base address and identified offset
 * - the reset driver sets respective relative bit for assert/deassert a reset
 * - the clock driver also has to set respective divider in source register
 *  - a dedicated sub-function (int set_freq(freq_t hz)) is required which is setting the respective clock source for a device
 *  - the clock driver sets the respective bits within selected source register
 */

OS_Error_t sysctrl_uart_enable(int uid) {

    // TODO: provide parallel access of several clients, e.g. like done in TimeServer

    sys_ctrl_ctx_t *ctx = &m_sys_ctrl_ctx;
    int error = 0;

    /* translate from provided uid to corresponding clock ID and reset ID, which are defined in respective mappings
     * provided by clock_bindings.h and reset_bindings.h
     */

    clk_id_t clk_id = uart_clk_id_map[uid];
    reset_id_t rst_id = uart_rst_id_map[uid];

    /* redirect to platform specific device_enable() function, implemented in /src/plat/<platform>/plat.c;
     * here, the platform specific device setup procedure is provided for both clock and reset
     */
    error = device_enable(ctx, clk_id, rst_id);

    return error;
}

OS_Error_t sysctrl_uart_disable(int uid) {
    // TODO: provide parallel access of several clients, e.g. like done in TimeServer

    // TODO: implement respective logic
    return 0;
}

OS_Error_t sysctrl_uart_setBaudRate(int uid) {
    /* TODO: call platform specific uart_setBaudRate() function
     *  - set frequency
     *  - set clock divider
    */

    // TODO: implement respective logic
    return 0;
}

int SystemController_init(sys_ctrl_ctx_t *ctx) {
    Debug_LOG_INFO("initialize SystemController");

    int error;
    if(plat_init) {
            /* perform some platform specific initialisation before initialising
             * the clock subsystem
             */
            error = plat_init(&(ctx->io_ops));
            ZF_LOGI_IF(error, "Failed to perform the platform initialisation");
    }

    /* for the Nvidia platforms there seems to be an implicit assumption that
     * the clock_sys_init() has to be used before the reset_sys_init(), as there
     * is the initial CAR region mapping done only as part of the clock initialisation
     */

    // call to respective function in /util_libs/libplatsupport or /projects_libs/libplatsupportports
    error = clock_sys_init(&(ctx->io_ops), &(ctx->io_ops.clock_sys));
    ZF_LOGI_IF(error, "Failed to initialise the clock subsystem");

    // call to respective function in /util_libs/libplatsupport or /projects_libs/libplatsupportports
    error = reset_sys_init(&(ctx->io_ops), NULL, &(ctx->io_ops.reset_sys));
    ZF_LOGI_IF(error, "Failed to initialise the reset subsystem");

    Debug_LOG_INFO("SystemController successfully initialized");

    return 0;
}


#ifdef BPMP_EXISTS
/******************************************************************************
* BPMP client initialization
******************************************************************************/

static int bpmpserver_call_wrapper(void *data, int mrq, void *tx_msg, size_t tx_size,
                                   void *rx_msg, size_t rx_size)
{
    if (!tx_msg) {
        ZF_LOGE("tx_msg is NULL!");
        return -EINVAL;
    }

    bpmpserver_interface_data_t *bpmpserver_data = data;

    if (tx_size >= bpmpserver_data->shared_mem_size) {
        ZF_LOGE("Supplied buffer is too large!");
        return -EINVAL;
    }

    /* Clean up the shared memory buffer */
    memset(bpmpserver_data->bpmpserver_shared_mem, 0, bpmpserver_data->shared_mem_size);

    /* Copy the tx_msg contents into the shared memory buffer, the buffers
     * shouldn't overlap so memcpy should be safe
     */
    memcpy(bpmpserver_data->bpmpserver_shared_mem, tx_msg, tx_size);

    size_t bytes_received = 0;
    int ret = bpmpserver_data->bpmpserver_call(mrq, tx_size, &bytes_received);

    if (ret >= 0 && rx_msg) {
        /* Copy the contents of the shared memory region (response from BPMP)
         * into the rx buffer
         */
        if (bytes_received > rx_size) {
            ZF_LOGW("Response received is larger than the buffer supplied");
        }
        memcpy(rx_msg, bpmpserver_data->bpmpserver_shared_mem, bytes_received);
        /* No error, return the amount of bytes received */
        return bytes_received;
    }

    /* Encountered an error so we return the error code */
    return ret;
}

int bpmpserver_interface_init(void *bpmpserver_shared_mem, size_t shared_mem_size,
                              int (*bpmpserver_call)(int mrq, size_t tx_size, size_t *bytes_rxd),
                              struct tx2_bpmp *bpmp)
{
    if (!bpmpserver_shared_mem) {
        ZF_LOGE("bpmpserver_shared_mem is NULL");
        return -EINVAL;
    }

    if (!bpmpserver_call) {
        ZF_LOGE("bpmpserver_call is NULL");
        return -EINVAL;
    }

    if (!bpmp) {
        ZF_LOGE("bpmp is NULL");
        return -EINVAL;
    }

    /* Setup the private data */
    bpmpserver_private_data.bpmpserver_shared_mem = bpmpserver_shared_mem;
    bpmpserver_private_data.bpmpserver_call = bpmpserver_call;
    bpmpserver_private_data.shared_mem_size = shared_mem_size;

    /* Setup the function pointer */
    bpmp->call = bpmpserver_call_wrapper;
    bpmp->data = &bpmpserver_private_data;

    return 0;
}

// Initialization to BPMPServer component and registration of interface
static int BPMPServer_client_init(sys_ctrl_ctx_t *ctx) {
    int error = bpmpserver_interface_init(sysctrl_bpmp_buf, sysctrl_bpmp_get_size(), sysctrl_bpmp_call, &(ctx->bpmp));
    if(error) {
        ZF_LOGE("Failed to initialise the BPMP server client interface");
        return -1;
    }

    error = ps_interface_register(&(ctx->io_ops.interface_registration_ops), TX2_BPMP_INTERFACE,
                                    &(ctx->bpmp), NULL);
    if(error) {
        ZF_LOGE("Failed to register the BPMP interface");
        return -1;
    }

    return 0;
}
#endif

void pre_init(void) {
    ZF_LOGE("Called pre_init()");
    sys_ctrl_ctx_t *ctx = &m_sys_ctrl_ctx;

    memset(ctx, 0, sizeof(*ctx));
    int error = camkes_io_ops(&(ctx->io_ops));
    ZF_LOGF_IF(error, "Failed to get camkes_io_ops");

#ifdef BPMP_EXISTS
    BPMPServer_client_init(ctx);
#endif
}


void post_init(void) {
    ZF_LOGE("Called post_init()");
    sys_ctrl_ctx_t *ctx = &m_sys_ctrl_ctx;
    int error = SystemController_init(ctx);
    ZF_LOGF_IF(error, "Failed to initialized SystemController");
}